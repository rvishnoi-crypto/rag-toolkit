"""
Query models for translation, routing, and classification.

These are used in two ways:
  1. As internal data structures passed between pipeline stages
  2. As structured output schemas for LLM calls (via .with_structured_output())

Pydantic Field descriptions matter here — they become part of the LLM prompt
when used with LangChain's structured output, so they guide the model's response.
"""

from enum import Enum
from typing import Optional
from pydantic import BaseModel, Field


# ---------------------------------------------------------------------------
# Query classification (used by routing)
# ---------------------------------------------------------------------------

class QueryType(str, Enum):
    """
    Categories a query can fall into.

    The router classifies every incoming query into one of these, then picks
    a retrieval strategy. Mirrors the pattern from AdaptiveRetrievalRAG
    but decoupled from any specific technique.
    """

    FACTUAL = "factual"
    ANALYTICAL = "analytical"
    OPINION = "opinion"
    CONTEXTUAL = "contextual"


class QueryClassification(BaseModel):
    """
    LLM-produced classification of a user query.

    Used as a structured output schema:
        chain = prompt | llm.with_structured_output(QueryClassification)

    The Field descriptions tell the LLM what format to produce.
    """

    query_type: QueryType = Field(description="The classified category of the query")
    confidence: float = Field(
        default=0.0,
        ge=0.0,
        le=1.0,
        description="How confident the classification is (0-1)",
    )
    reasoning: str = Field(
        default="",
        description="Brief explanation of why this category was chosen",
    )


# ---------------------------------------------------------------------------
# Query translation (rewrite, multi-query, decomposition)
# ---------------------------------------------------------------------------

class TranslatedQuery(BaseModel):
    """
    A single rewritten version of the original query.

    The translator produces this — one original query becomes one (rewrite)
    or many (multi-query) TranslatedQuery objects.
    """

    original: str = Field(description="The original user query")
    rewritten: str = Field(description="The transformed query for retrieval")
    method: str = Field(
        default="rewrite",
        description="Which translation method produced this (rewrite, step_back, hyde)",
    )


class MultiQueryExpansion(BaseModel):
    """
    LLM-produced set of alternative query perspectives.

    Used as structured output — the LLM generates multiple rewrites at once.
    Each variant approaches the same question from a different angle to
    improve retrieval coverage.
    """

    variants: list[str] = Field(
        description="3-5 alternative phrasings of the query from different perspectives"
    )


class SubQuestions(BaseModel):
    """
    LLM-produced decomposition of a complex query into simpler sub-questions.

    Used for analytical queries where the answer requires synthesizing
    information from multiple retrieval passes.
    """

    questions: list[str] = Field(
        description="2-3 simpler sub-questions that together answer the original query"
    )


class HyDEDocument(BaseModel):
    """
    A hypothetical document generated by the LLM.

    HyDE (Hypothetical Document Embedding) works by asking the LLM to
    *imagine* an ideal document that answers the query, then using that
    document's embedding for retrieval instead of the query's embedding.
    This bridges the semantic gap between questions and answers.
    """

    content: str = Field(
        description="A detailed hypothetical passage that would answer the query (~200 words)"
    )


# ---------------------------------------------------------------------------
# Route decision (output of the router)
# ---------------------------------------------------------------------------

class RouteDecision(BaseModel):
    """
    The router's decision on how to handle a query.

    Contains the classification plus the chosen strategy name, so downstream
    components know which retrieval path to take.
    """

    classification: QueryClassification
    strategy: str = Field(
        default="default",
        description="Name of the retrieval strategy to use",
    )
