"""
Query models for translation, routing, and classification.

These are used in two ways:
  1. As internal data structures passed between pipeline stages
  2. As structured output schemas for LLM calls (via .with_structured_output())

Pydantic Field descriptions matter here — they become part of the LLM prompt
when used with LangChain's structured output, so they guide the model's response.
"""

from enum import Enum
from typing import Optional
from pydantic import BaseModel, Field


# ---------------------------------------------------------------------------
# Query classification (used by routing)
# ---------------------------------------------------------------------------

class QueryType(str, Enum):
    """
    Categories a query can fall into.

    The router classifies every incoming query into one of these, then picks
    a retrieval strategy. Mirrors the pattern from AdaptiveRetrievalRAG
    but decoupled from any specific technique.
    """

    FACTUAL = "factual"
    ANALYTICAL = "analytical"
    OPINION = "opinion"
    CONTEXTUAL = "contextual"


class QueryClassification(BaseModel):
    """
    LLM-produced classification of a user query.

    Used as a structured output schema:
        chain = prompt | llm.with_structured_output(QueryClassification)

    The Field descriptions tell the LLM what format to produce.
    """

    query_type: QueryType = Field(description="The classified category of the query")
    confidence: float = Field(
        default=0.0,
        ge=0.0,
        le=1.0,
        description="How confident the classification is (0-1)",
    )
    reasoning: str = Field(
        default="",
        description="Brief explanation of why this category was chosen",
    )


# ---------------------------------------------------------------------------
# Query translation (rewrite, multi-query, decomposition)
# ---------------------------------------------------------------------------

class TranslatedQuery(BaseModel):
    """
    A single rewritten version of the original query.

    The translator produces this — one original query becomes one (rewrite)
    or many (multi-query) TranslatedQuery objects.
    """

    original: str = Field(description="The original user query")
    rewritten: str = Field(description="The transformed query for retrieval")
    method: str = Field(
        default="rewrite",
        description="Which translation method produced this (rewrite, step_back, hyde)",
    )


class MultiQueryExpansion(BaseModel):
    """
    LLM-produced set of alternative query perspectives.

    Used as structured output — the LLM generates multiple rewrites at once.
    Each variant approaches the same question from a different angle to
    improve retrieval coverage.
    """

    variants: list[str] = Field(
        description="3-5 alternative phrasings of the query from different perspectives"
    )


class SubQuestions(BaseModel):
    """
    LLM-produced decomposition of a complex query into simpler sub-questions.

    Used for analytical queries where the answer requires synthesizing
    information from multiple retrieval passes.
    """

    questions: list[str] = Field(
        description="2-3 simpler sub-questions that together answer the original query"
    )


class HyDEDocument(BaseModel):
    """
    A hypothetical document generated by the LLM.

    HyDE (Hypothetical Document Embedding) works by asking the LLM to
    *imagine* an ideal document that answers the query, then using that
    document's embedding for retrieval instead of the query's embedding.
    This bridges the semantic gap between questions and answers.
    """

    content: str = Field(
        description="A detailed hypothetical passage that would answer the query (~200 words)"
    )


# ---------------------------------------------------------------------------
# Query construction (NL → structured query for DBs)
# ---------------------------------------------------------------------------

class QueryTarget(str, Enum):
    """
    Which backend a constructed query targets.

    The router uses this to decide whether to send the query down
    the vector path (translator → vector store) or the structured
    path (constructor → database).
    """

    VECTOR_STORE = "vector_store"
    SQL_DATABASE = "sql_database"
    GRAPH_DATABASE = "graph_database"
    METADATA_FILTER = "metadata_filter"


class ConstructedQuery(BaseModel):
    """
    A natural language query converted into a structured query.

    This is the output of the query constructor — it holds the actual
    query string (SQL, Cypher, metadata filter dict, etc.) plus metadata
    about what produced it.

    Examples:
        ConstructedQuery(
            original="revenue over 1M last quarter",
            constructed="SELECT * FROM revenue WHERE amount > 1000000 AND quarter = 'Q4'",
            target=QueryTarget.SQL_DATABASE,
        )
        ConstructedQuery(
            original="find users connected to Alice",
            constructed="MATCH (a:User {name: 'Alice'})-[:FOLLOWS]->(f) RETURN f",
            target=QueryTarget.GRAPH_DATABASE,
        )
        ConstructedQuery(
            original="papers about RAG from 2024",
            constructed='{"year": 2024, "topic": "RAG"}',
            target=QueryTarget.METADATA_FILTER,
        )
    """

    original: str = Field(description="The original natural language query")
    constructed: str = Field(description="The structured query (SQL, Cypher, filter JSON, etc.)")
    target: QueryTarget = Field(description="Which backend this query targets")
    method: str = Field(
        default="text_to_sql",
        description="Which construction method produced this (text_to_sql, text_to_cypher, metadata_filter)",
    )


# ---------------------------------------------------------------------------
# Route decision (output of the router)
# ---------------------------------------------------------------------------

class RetrievalPath(str, Enum):
    """
    Which retrieval path the router chooses.

    VECTOR:     query goes through translator → vector store
    STRUCTURED: query goes through constructor → database
    HYBRID:     both paths run, results are merged
    """

    VECTOR = "vector"
    STRUCTURED = "structured"
    HYBRID = "hybrid"


class RouteDecision(BaseModel):
    """
    The router's decision on how to handle a query.

    Contains the classification, the chosen retrieval path, and the
    strategy name. This is the single object that tells downstream
    components exactly what to do.

    Examples:
        # Pure vector search for a factual question
        RouteDecision(classification=..., path=RetrievalPath.VECTOR, strategy="factual")

        # SQL query for a data lookup
        RouteDecision(classification=..., path=RetrievalPath.STRUCTURED, strategy="text_to_sql")

        # Both paths for a question that needs docs + data
        RouteDecision(classification=..., path=RetrievalPath.HYBRID, strategy="hybrid")
    """

    classification: QueryClassification
    path: RetrievalPath = Field(
        default=RetrievalPath.VECTOR,
        description="Which retrieval path to use",
    )
    strategy: str = Field(
        default="default",
        description="Name of the retrieval strategy to use",
    )
